{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\HP\\\\Desktop\\\\Flightbooking\\\\React-flight-booking-master\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport flightData from './../data.json';\nimport { transformFlightDates } from './utils'; //Using a graph algorithm to recursively explore all the connected nodes and find all connected flight paths\n\nfunction paths({\n  graph = [],\n  from,\n  to,\n  date\n}, path = []) {\n  const linkedNodes = connectedNodes(nodes.bind(null, graph));\n  return explore(from, to);\n\n  function explore(currNode, to, paths = [], originalNode) {\n    path.push(originalNode || currNode);\n\n    for (let linkedNode of linkedNodes(currNode)) {\n      if (linkedNode.destination === to) {\n        let result = path.slice(); // copy values\n\n        result.push(_objectSpread({}, linkedNode));\n        paths.push(result);\n        continue;\n      } // do not traverse paths already explored\n\n\n      if (!hasEdgeBeenTraversedInPath({\n        edge: {\n          from: currNode,\n          to: linkedNode.destination\n        },\n        path: path.map(a => a && a.destination ? a.destination : a)\n      })) {\n        explore(linkedNode.destination, to, paths, linkedNode);\n      }\n    }\n\n    path.pop(); // sub-graph fully explored \n\n    return paths;\n  }\n}\n/** \n* Get all nodes linked \n* to from `node`.\n*/\n\n\nfunction nodes(graph, node) {\n  const list = graph.reduce((p, c) => {\n    c.origin === node && p.push({\n      destination: c.destination,\n      config: _objectSpread({}, c)\n    });\n    return p;\n  }, []);\n  return list;\n}\n/**\n* Has an edge been followed \n* in the given path?\n*/\n\n\nfunction hasEdgeBeenTraversedInPath({\n  edge,\n  path\n}) {\n  var indices = allIndices(path, edge.from);\n  return indices.some(i => path[i + 1] === edge.to);\n}\n/**\n* Utility to get all indices of \n* values matching `val` in `arr`.\n*/\n\n\nfunction allIndices(arr, value) {\n  var indices = [],\n      i;\n\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] === value) {\n      indices.push(i);\n    }\n  }\n\n  return indices;\n}\n/**\n* Avoids recalculating flight route \n* nodes.\n*/\n\n\nfunction connectedNodes(fn) {\n  const flightCache = new Map();\n  return function () {\n    var key = JSON.stringify(arguments);\n    var cached = flightCache.get(key);\n\n    if (cached) {\n      return cached;\n    }\n\n    cached = fn.apply(this, arguments);\n    flightCache.set(key, cached);\n    return cached;\n  };\n}\n\nfunction filterPaths(paths, date, numOfPassengers) {\n  const list = paths.filter(path => {\n    return isSameDestination(path);\n  });\n  const finalPaths = list.filter(path => {\n    return checkLayoverCriteria(path, date);\n  });\n  const transformedPaths = {\n    nonStopFlights: [],\n    multiStopFlights: []\n  };\n  finalPaths.forEach((path, index) => {\n    if (path.length === 2) {\n      transformedPaths.nonStopFlights.push(_objectSpread({}, path[1].config, {\n        price: path[1].config.price * (parseInt(numOfPassengers) || 1)\n      }));\n    } else {\n      let totalFare = 0,\n          multiFlights = [],\n          layovers = path.length - 1;\n\n      for (let i = 1; i < path.length; i++) {\n        multiFlights.push(_objectSpread({}, path[i].config));\n        totalFare += path[i].config.price;\n      }\n\n      transformedPaths.multiStopFlights.push({\n        cumulativeFlight: {\n          origin: path[0],\n          destination: path[layovers].destination,\n          date: path[1].config.date,\n          departureTime: path[1].config.departureTime,\n          arrivalTime: path[layovers].config.arrivalTime,\n          arrivalTimeStamp: path[layovers].config.arrivalTimeStamp,\n          departureTimeStamp: path[1].config.departureTimeStamp,\n          dayChange: path[1].config.date !== path[layovers].config.date,\n          totalFare: totalFare * (parseInt(numOfPassengers) || 1)\n        },\n        flights: multiFlights\n      });\n    }\n\n    return transformedPaths;\n  });\n  return transformedPaths;\n}\n\nfunction checkLayoverCriteria(path, startDate) {\n  let lowerLayover = false;\n\n  if (path.length > 1 && path[1].config.date !== startDate.replace(/-/g, '/')) {\n    return false;\n  }\n\n  for (let i = 0; i < path.length - 1; i++) {\n    if (typeof path[i] === \"object\" && typeof path[i + 1] === \"object\" && path[i + 1].config.departureTimeStamp - path[i].config.arrivalTimeStamp <= 1800000) {\n      lowerLayover = true;\n      break;\n    }\n  }\n\n  return !lowerLayover;\n}\n\nfunction isSameDestination(links) {\n  let duplicate = false;\n  let keys = {};\n\n  for (let i = 0; i < links.length; i++) {\n    const keyName = links[i] && links[i].destination ? links[i].destination : links[i];\n\n    if (keys.hasOwnProperty(keyName)) {\n      duplicate = true;\n      break;\n    }\n\n    keys[keyName] = links[i];\n  }\n\n  return !duplicate;\n}\n\nexport function findPaths({\n  flights = transformFlightDates(flightData),\n  criteria = {\n    origin: 'Bengaluru (BLR)',\n    destination: 'Delhi (DEL)'\n  }\n}) {\n  return filterPaths(paths({\n    graph: flights,\n    from: criteria.origin,\n    to: criteria.destination\n  }), criteria.date, criteria.numOfPassengers);\n}","map":{"version":3,"sources":["C:\\Users\\HP\\Desktop\\Flightbooking\\React-flight-booking-master\\src\\lib\\flightManager.js"],"names":["flightData","transformFlightDates","paths","graph","from","to","date","path","linkedNodes","connectedNodes","nodes","bind","explore","currNode","originalNode","push","linkedNode","destination","result","slice","hasEdgeBeenTraversedInPath","edge","map","a","pop","node","list","reduce","p","c","origin","config","indices","allIndices","some","i","arr","value","length","fn","flightCache","Map","key","JSON","stringify","arguments","cached","get","apply","set","filterPaths","numOfPassengers","filter","isSameDestination","finalPaths","checkLayoverCriteria","transformedPaths","nonStopFlights","multiStopFlights","forEach","index","price","parseInt","totalFare","multiFlights","layovers","cumulativeFlight","departureTime","arrivalTime","arrivalTimeStamp","departureTimeStamp","dayChange","flights","startDate","lowerLayover","replace","links","duplicate","keys","keyName","hasOwnProperty","findPaths","criteria"],"mappings":"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","sourcesContent":["import flightData from './../data.json';\nimport { transformFlightDates } from './utils';\n\n//Using a graph algorithm to recursively explore all the connected nodes and find all connected flight paths\nfunction paths({ graph = [], from, to, date }, path = []) {\n  const linkedNodes = connectedNodes(nodes.bind(null, graph));\n  return explore(from, to);\n\n  function explore(currNode, to, paths = [], originalNode) {\n    path.push(originalNode || currNode);\n    for (let linkedNode of linkedNodes(currNode)) {\n      if (linkedNode.destination === to) {\n        let result = path.slice(); // copy values\n        result.push({ ...linkedNode });\n        paths.push(result);\n        continue;\n      }\n      // do not traverse paths already explored\n      if (!hasEdgeBeenTraversedInPath({\n        edge: {\n          from: currNode,\n          to: linkedNode.destination\n        },\n        path: path.map(a => a && a.destination ? a.destination : a)\n      })) {\n        explore(linkedNode.destination, to, paths, linkedNode);\n      }\n    }\n    path.pop(); // sub-graph fully explored \n\n    return paths;\n  }\n}\n\n/** \n* Get all nodes linked \n* to from `node`.\n*/\nfunction nodes(graph, node) {\n  const list = graph.reduce((p, c) => {\n    (c.origin === node) && p.push({ destination: c.destination, config: { ...c } });\n    return p;\n  }, []);\n  return list;\n}\n\n/**\n* Has an edge been followed \n* in the given path?\n*/\nfunction hasEdgeBeenTraversedInPath({ edge, path }) {\n  var indices = allIndices(path, edge.from);\n  return indices.some(i => path[i + 1] === edge.to);\n}\n\n/**\n* Utility to get all indices of \n* values matching `val` in `arr`.\n*/\nfunction allIndices(arr, value) {\n  var indices = [],\n    i;\n  for (i = 0; i < arr.length; i++) {\n    if (arr[i] === value) {\n      indices.push(i);\n    }\n  }\n  return indices;\n}\n\n/**\n* Avoids recalculating flight route \n* nodes.\n*/\nfunction connectedNodes(fn) {\n  const flightCache = new Map();\n  return function () {\n    var key = JSON.stringify(arguments);\n    var cached = flightCache.get(key);\n    if (cached) {\n      return cached;\n    }\n    cached = fn.apply(this, arguments)\n    flightCache.set(key, cached);\n    return cached;\n  };\n}\n\nfunction filterPaths(paths, date, numOfPassengers) {\n\n  const list = paths.filter(path => {\n    return isSameDestination(path);\n  });\n\n  const finalPaths = list.filter(path => {\n    return checkLayoverCriteria(path, date);\n  });\n\n  const transformedPaths = {\n    nonStopFlights: [],\n    multiStopFlights: [],\n  }\n\n  finalPaths.forEach((path, index) => {\n    if (path.length === 2) {\n      transformedPaths.nonStopFlights.push({\n        ...path[1].config,\n        price: path[1].config.price * (parseInt(numOfPassengers) || 1)\n      })\n    }\n    else {\n      let totalFare = 0, multiFlights = [], layovers = path.length - 1;\n      for (let i = 1; i < path.length; i++) {\n        multiFlights.push({ ...path[i].config });\n        totalFare += path[i].config.price;\n      }\n\n      transformedPaths.multiStopFlights.push({\n        cumulativeFlight: {\n          origin: path[0],\n          destination: path[layovers].destination,\n          date: path[1].config.date,\n          departureTime: path[1].config.departureTime,\n          arrivalTime: path[layovers].config.arrivalTime,\n          arrivalTimeStamp: path[layovers].config.arrivalTimeStamp,\n          departureTimeStamp: path[1].config.departureTimeStamp,\n          dayChange: path[1].config.date !== path[layovers].config.date,\n          totalFare: totalFare * (parseInt(numOfPassengers) || 1)\n        },\n        flights: multiFlights\n      })\n    }\n\n    return transformedPaths;\n  });\n\n  return transformedPaths;\n}\n\nfunction checkLayoverCriteria(path, startDate) {\n  let lowerLayover = false;\n\n  if (path.length > 1 && (path[1].config.date !== startDate.replace(/-/g, '/'))) {\n    return false;\n  }\n\n  for (let i = 0; i < path.length - 1; i++) {\n    if (typeof path[i] === \"object\" && typeof path[i + 1] === \"object\" && path[i + 1].config.departureTimeStamp - path[i].config.arrivalTimeStamp <= 1800000) {\n      lowerLayover = true;\n      break;\n    }\n  }\n\n  return !lowerLayover;\n}\n\nfunction isSameDestination(links) {\n  let duplicate = false;\n  let keys = {};\n  for (let i = 0; i < links.length; i++) {\n    const keyName = links[i] && links[i].destination ? links[i].destination : links[i];\n    if (keys.hasOwnProperty(keyName)) {\n      duplicate = true;\n      break;\n    }\n    keys[keyName] = links[i]\n  }\n  return !duplicate;\n}\n\nexport function findPaths({ flights = transformFlightDates(flightData), criteria = { origin: 'Bengaluru (BLR)', destination: 'Delhi (DEL)' } }) {\n  return filterPaths(paths({\n    graph: flights,\n    from: criteria.origin,\n    to: criteria.destination,\n  }), criteria.date, criteria.numOfPassengers)\n}\n\n"]},"metadata":{},"sourceType":"module"}